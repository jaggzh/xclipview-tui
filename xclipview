#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
An interactive TUI (Text User Interface) clipboard viewer using xclip.

This script features a dynamic, resilient layout with a full-height pane
separator and correctly handles all text drawing to prevent crashes.

Controls:
- Left/Right Arrows (h/l): Switch between primary, secondary, and clipboard.
- Up/Down Arrows (k/j):   Navigate the list of available targets.
- r:                      Reload the content of the current clipboard.
- q:                      Quit the application.
"""
import curses
import subprocess
import datetime
import textwrap
import sys
import os

class Tui:
    """The main class for the Text User Interface."""
    MIN_HEIGHT = 8
    MIN_WIDTH = 30

    def __init__(self, stdscr):
        self.stdscr = stdscr
        self.selections = ['primary', 'secondary', 'clipboard']
        self.current_selection_index = 0
        self.targets, self.contents, self.navigable_indices = [], {}, []
        self.selected_nav_index = 0
        self.COLORS = { 'default': 1, 'highlight': 2, 'special': 3, 'header': 4, 'header_active': 5, 'key': 6 }

    def setup(self):
        """Initializes colors and fetches initial data."""
        curses.curs_set(0)
        self._init_colors()
        self.fetch_clipboard_data()

    def _init_colors(self):
        curses.start_color()
        curses.use_default_colors()
        curses.init_pair(self.COLORS['default'], curses.COLOR_WHITE, -1)
        curses.init_pair(self.COLORS['highlight'], curses.COLOR_BLACK, curses.COLOR_WHITE)
        curses.init_pair(self.COLORS['special'], 244, -1) # Grey
        curses.init_pair(self.COLORS['header'], curses.COLOR_YELLOW, curses.COLOR_BLUE)
        curses.init_pair(self.COLORS['header_active'], curses.COLOR_BLACK, curses.COLOR_YELLOW)
        curses.init_pair(self.COLORS['key'], curses.COLOR_CYAN, -1)


    def _safe_addstr(self, win, y, x, text, attr=None):
        """A robust replacement for addstr that only truncates, preventing errors."""
        if attr is None: attr = curses.A_NORMAL
        height, width = win.getmaxyx()
        if y >= height or x >= width or y < 0 or x < 0: return
        max_len = width - x
        if max_len <= 0: return
        truncated_text = text[:max_len]
        try: win.addstr(y, x, truncated_text, attr)
        except curses.error: pass

    def fetch_clipboard_data(self):
        """Fetches all targets and content for the current clipboard."""
        self.targets, self.contents, self.navigable_indices = [], {}, []
        self.selected_nav_index = 0
        selection_name = self.selections[self.current_selection_index]
        try:
            targets_raw = subprocess.check_output(
                ["xclip", "-selection", selection_name, "-t", "TARGETS", "-o"],
                stderr=subprocess.PIPE, text=True, errors='ignore'
            )
            self.targets = [t for t in targets_raw.strip().split('\n') if t]
        except (FileNotFoundError, subprocess.CalledProcessError): return
        for i, target in enumerate(self.targets):
            try:
                content_bytes = subprocess.check_output(
                    ["xclip", "-selection", selection_name, "-t", target, "-o"],
                    stderr=subprocess.DEVNULL
                )
                decoded_content = "".join(
                    char if char.isprintable() or char in '\n\t' else '.'
                    for char in content_bytes.decode('utf-8', errors='replace')
                )
                self.contents[target] = decoded_content
                if decoded_content: self.navigable_indices.append(i)
            except subprocess.CalledProcessError: self.contents[target] = ""

    def handle_input(self, key):
        """Processes user key presses."""
        if key == ord('q'): return False
        
        if key == ord('r'):
            curses.flash()
            self.fetch_clipboard_data()
        elif key in (ord('j'), curses.KEY_DOWN):
            if self.navigable_indices and self.selected_nav_index < len(self.navigable_indices) - 1: self.selected_nav_index += 1
        elif key in (ord('k'), curses.KEY_UP):
            if self.navigable_indices and self.selected_nav_index > 0: self.selected_nav_index -= 1
        elif key in (ord('h'), curses.KEY_LEFT):
            if self.current_selection_index > 0:
                self.current_selection_index -= 1; self.fetch_clipboard_data()
        elif key in (ord('l'), curses.KEY_RIGHT):
            if self.current_selection_index < len(self.selections) - 1:
                self.current_selection_index += 1; self.fetch_clipboard_data()
        return True

    def run_loop(self):
        """Main application loop."""
        running = True
        while running:
            self.draw()
            key = self.stdscr.getch()
            if key == curses.KEY_RESIZE: continue
            running = self.handle_input(key)

    def draw(self):
        """Main drawing function."""
        height, width = self.stdscr.getmaxyx()
        self.stdscr.erase()
        if height < self.MIN_HEIGHT or width < self.MIN_WIDTH:
            self._safe_addstr(self.stdscr, 0, 0, "Terminal too small.")
            self.stdscr.refresh()
            return
        
        self._draw_header(height, width)
        self._draw_left_pane(height, width)
        self.stdscr.refresh()
        self._draw_right_pane(height, width)

    def _draw_header(self, height, width):
        x_pos = 1
        for i, selection in enumerate(self.selections):
            style = self.COLORS['header_active'] if i == self.current_selection_index else self.COLORS['header']
            display_text = f" {selection.upper()} "
            self._safe_addstr(self.stdscr, 0, x_pos, display_text, curses.color_pair(style))
            x_pos += len(display_text) + 1
        self._safe_addstr(self.stdscr, 1, 0, "─" * width)
        xclip_cmd = f"$ xclip -selection {self.selections[self.current_selection_index]} -t TARGETS -o"
        self._safe_addstr(self.stdscr, 2, 0, xclip_cmd)

    def _draw_left_pane(self, height, width):
        """Draws left pane with a full-height separator line that is never overwritten."""
        pane_width = width // 3
        
        self._safe_addstr(self.stdscr, 3, 0, "TARGETS:")
        
        current_target_index = self.navigable_indices[self.selected_nav_index] if self.navigable_indices else -1
        
        last_y = 3
        for i, target in enumerate(self.targets):
            y = 4 + i
            if y >= height - 1: break
            display_str = target
            
            # Clear line segment before drawing
            self.stdscr.addstr(y, 0, ' ' * (pane_width))
            
            if i == current_target_index: attr = curses.color_pair(self.COLORS['highlight'])
            elif not self.contents.get(target): attr = curses.color_pair(self.COLORS['special']); display_str = f"* {target}"
            else: attr = curses.color_pair(self.COLORS['default'])
                
            if target == "TIMESTAMP" and self.contents.get(target):
                try: display_str = f"{target} \"{datetime.datetime.fromtimestamp(int(self.contents[target])).strftime('%Y-%m-%d %H:%M:%S')}\""
                except (ValueError, TypeError): pass

            self._safe_addstr(self.stdscr, y, 0, display_str, attr)
            last_y = y

        help_y_start = last_y + 2
        help_items = [("h/l", "←→ Select Clipboard"), ("j/k", "↑↓ Navigate Targets"), ("r", "Reload"), ("q", "Quit")]
        key_style, default_style = curses.color_pair(self.COLORS['key']), curses.color_pair(self.COLORS['default'])

        for i, (key, desc) in enumerate(help_items):
            y = help_y_start + i
            if y >= height: break
            self.stdscr.addstr(y, 0, ' ' * (pane_width)) # Clear line segment
            desc_x = 1 + len(key) + 1
            self._safe_addstr(self.stdscr, y, 1, key, key_style)
            self._safe_addstr(self.stdscr, y, desc_x, desc, default_style)

        # After drawing all text, redraw the separator to ensure it's on top.
        try: self.stdscr.vline(3, pane_width, curses.ACS_VLINE, height - 3)
        except curses.error: pass

    def _draw_right_pane(self, height, width):
        """Draws content in a full-height pane, with padding and safety checks."""
        pane_y, pane_x = 4, (width // 3) + 1
        pane_h, pane_w = height - pane_y, width - pane_x
        if pane_h <= 0 or pane_w <= 0: return

        content_win = curses.newwin(pane_h, pane_w, pane_y, pane_x)
        content = "[No target selected or target has no content]"
        if self.navigable_indices:
            if self.selected_nav_index >= len(self.navigable_indices): self.selected_nav_index = max(0, len(self.navigable_indices) - 1)
            if self.navigable_indices:
                selected_target_index = self.navigable_indices[self.selected_nav_index]
                selected_target = self.targets[selected_target_index]
                content = self.contents.get(selected_target, "[Error]")
        
        display_lines = []
        original_lines = content.split('\n')
        for line in original_lines:
            # FIX: Wrap to pane_w - 1 to create padding on the right.
            wrapped_sublines = textwrap.wrap(line, width=max(1, pane_w - 1), replace_whitespace=False)
            if not wrapped_sublines: display_lines.append('')
            else: display_lines.extend(wrapped_sublines)
        
        for i, line in enumerate(display_lines):
            # FIX: Add bounds check to prevent drawing outside the window.
            if i >= pane_h:
                break
            self._safe_addstr(content_win, i, 0, line)
        content_win.refresh()


def main(stdscr):
    try: subprocess.run(["which", "xclip"], check=True, capture_output=True)
    except (FileNotFoundError, subprocess.CalledProcessError):
        curses.endwin()
        print("Error: `xclip` command not found.", file=sys.stderr)
        sys.exit(1)
    app = Tui(stdscr)
    app.setup()
    app.run_loop()

if __name__ == "__main__":
    if not os.isatty(sys.stdout.fileno()):
         print("Error: This is a TUI application and must be run in a terminal.", file=sys.stderr)
         sys.exit(1)
    try: curses.wrapper(main)
    except Exception as e: print(f"An unexpected error occurred: {e}", file=sys.stderr)